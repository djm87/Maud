/*
 * @(#)NeuralNetworkGraph.java created Mar 22, 2006 Casalino
 *
 * Copyright (c) 1996-2006 Luca Lutterotti All Rights Reserved.
 *
 * This software is the research result of Luca Lutterotti and it is 
 * provided as it is as confidential and proprietary information.  
 * You shall not disclose such Confidential Information and shall use 
 * it only in accordance with the terms of the license agreement you 
 * entered into with the author.
 *
 * THE AUTHOR MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
 * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, OR NON-INFRINGEMENT. THE AUTHOR SHALL NOT BE LIABLE FOR ANY DAMAGES
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
 * THIS SOFTWARE OR ITS DERIVATIVES.
 *
 */

package it.unitn.ing.rista.neuralnetwork;

import javax.swing.*;
import java.awt.*;


/**
 * The NeuralNetworkGraph is a class
 * <p/>
 * Description
 *
 * @author Luca Lutterotti
 * @version $Revision: 1.1 $, $Date: 2006/07/20 14:06:04 $
 * @since JDK1.1
 */

public class NeuralNetworkGraph extends JPanel {

    /** Creates new form NeuralNetworkGraph */
    public NeuralNetworkGraph() {
        initComponents();

        border = 10;
        leftBorder = 30;
  bottomBorder = 30;
  fontSize = 10;
      width  = 370; // size of the graph
  height = 230;
      minVal = 0.0;
      maxVal = 1.1;
  minLim = 0.0;

        clear();
        setPreferredSize(new Dimension(width+1, height+1));
        setMinimumSize(new Dimension(width+1, height+1));
        setMaximumSize(new Dimension(width+1, height+1));
        setLayout(new GridLayout(1,0));
    }

    public void addError(double err) {
        if(nElements == error.length) {
            double temp[] = error;
            error = new double[error.length + block];
                System.arraycopy(temp,0,error,0,nElements);
        }

        error[nElements] = err;

        if(maxVal < err) maxVal = err;

        nElements++;

        repaint();
    }

    public void clear() {
        nElements = 1;
        error = new double[block];
        error[0] = 0.0;
        minVal = 0.0;
        maxVal = 1.1;
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

  int stepX = (width-border-leftBorder)/nElements;
  int graphH = height-border-bottomBorder;
//  int graphY = border;
        double x;
  int y;

  // The graph cannt fit in any more data.
        // Reset the previous data drawn in the graph.
        if(stepX == 0) clear();

        // create an image to avoid flicks
  Image image = createImage(width, height);
  Graphics g2 = image.getGraphics();

  g2.setFont(new Font("Helvetica", Font.PLAIN , fontSize));

  g2.setColor(Color.black);
  g2.fillRect(0, 0, width, height);

  g2.setColor(Color.white);
        // Draw a line from top to bottom as Y-axis.
  g2.drawLine(leftBorder, border, leftBorder, height-(bottomBorder*3/4));
        // Draw a line from left to right as X-axis.
  g2.drawLine(leftBorder*3/4, height-bottomBorder, width-border, height-bottomBorder);

        g2.setColor(Color.lightGray);

  x = 0.0;
        while((double)x < maxVal) {
            y = scale((double)x, minVal, maxVal, 0, graphH);
            g2.drawLine(leftBorder-2, height-bottomBorder-y, width-border, height-bottomBorder-y);
            g2.drawString(""+(float)x, 2, height-bottomBorder-y+fontSize/2);

            if(maxVal > 4.0) {
                x+=2.0;
            }
            else if(maxVal > 8.0) {
                x+=4.0;
            }
            else x+=0.2;
        }

  if(minLim < maxVal) {
            g2.setColor(Color.red);
            y = scale(minLim, minVal, maxVal, 0, graphH);
            g2.drawLine(leftBorder+1, height-bottomBorder-y, width-border,height-bottomBorder-y);
            g2.drawString(""+minLim, 2, height-bottomBorder-y+fontSize/2);
        }

        g2.setColor(Color.yellow);
        for(int i=2; i < nElements; i++) {
            int y1 = scale(error[i-1], minVal, maxVal, 0, 0+graphH);
            int y2 = scale(error[i], minVal, maxVal, 0, graphH);

            g2.drawLine(leftBorder+1+((i-1)*stepX), height-bottomBorder-y1, leftBorder+1+(i*stepX), height-bottomBorder-y2);
  }

  g.drawImage(image, 0, 0, this);
    }

    public static int scale(double x, double xMin, double xMax, int toMin, int toMax) {
        return (int)((x-xMin)/(xMax-xMin)*(double)(toMax-toMin))+toMin;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents

        setLayout(new java.awt.BorderLayout());

    }//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    public static final int block = 500;

    private int	border = 10;
    private int	leftBorder = 30;
    private int	bottomBorder = 30;
    private int	fontSize = 10;
    private int width  = 370; // size of the graph
    private int height = 230;
    private double minVal = 0.0;
    private double maxVal = 1.1;
    private double minLim = 0.0;

    private double error[];
    private int nElements;



}
