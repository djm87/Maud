/*
 * @(#)NeuralNetworkPanel.java created Mar 22, 2006 Casalino
 *
 * Copyright (c) 1996-2006 Luca Lutterotti All Rights Reserved.
 *
 * This software is the research result of Luca Lutterotti and it is 
 * provided as it is as confidential and proprietary information.  
 * You shall not disclose such Confidential Information and shall use 
 * it only in accordance with the terms of the license agreement you 
 * entered into with the author.
 *
 * THE AUTHOR MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
 * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, OR NON-INFRINGEMENT. THE AUTHOR SHALL NOT BE LIABLE FOR ANY DAMAGES
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
 * THIS SOFTWARE OR ITS DERIVATIVES.
 *
 */

package it.unitn.ing.rista.neuralnetwork;

import javax.swing.*;
import java.awt.*;
import java.io.*;

import org.joone.engine.*;
import org.joone.engine.learning.*;
import org.joone.io.*;

/**
 * The NeuralNetworkPanel is a class
 * <p/>
 * Description
 *
 * @author Luca Lutterotti
 * @version $Revision: 1.1 $, $Date: 2006/07/20 14:06:04 $
 * @since JDK1.1
 */

public class NeuralNetworkPanel extends JPanel {

  NeuralNetworkGraphPanel neuralNetworkGraphPanel;
  NeuralNetworkControlPanel neuralNetworkControlPanel;

  /**
   * The input layer of neurons.
   */
  SigmoidLayer input;

  /**
   * The hidden layer of neurons.
   */
  SigmoidLayer hidden;

  /**
   * The output layer of neurons.
   */
  SigmoidLayer output;


  /**
   * Used to train the neural network.
   */
  TeachingSynapse trainer;

  FullSynapse t1, t2;

  Monitor monitor;

  private static final int PREFERRED_WIDTH = 630;
  private static final int PREFERRED_HEIGHT = 500;

  /**
   * Creates new form NeuralNetworkPanel
   */
  public NeuralNetworkPanel() {
    initComponents();

    neuralNetworkGraphPanel = new NeuralNetworkGraphPanel();
    neuralNetworkControlPanel = new NeuralNetworkControlPanel();

    input = null;
    hidden = null;
    output = null;
    monitor = null;
    trainer = null;
    t1 = null;
    t2 = null;

    Dimension minimumSize = new Dimension((int) ((double) PREFERRED_WIDTH / 4.0),
          (int) ((double) PREFERRED_HEIGHT / 4.0));
    neuralNetworkGraphPanel.setMinimumSize(minimumSize);
    neuralNetworkControlPanel.setMinimumSize(minimumSize);

    JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
          neuralNetworkGraphPanel, neuralNetworkControlPanel);

    splitPane.setDividerLocation(380);
    splitPane.setOneTouchExpandable(true);

    add(splitPane);
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents() {//GEN-BEGIN:initComponents

    setLayout(new java.awt.BorderLayout());

    setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(5, 5, 5, 5)));
  }//GEN-END:initComponents

  public Dimension getPreferredSize() {
    return new Dimension(PREFERRED_WIDTH, PREFERRED_HEIGHT);
  }

  public void stopNetwork() {
    if (monitor != null) {
      monitor.Stop();
    }
  }

  public double[] runNetwork(int numOfInput, double[][] inputArray) {
    if (input == null || hidden == null || output == null) {
      return new double[0];
    }

    input.removeAllInputs();
    //
    // A workaround to make sure the stop call back function will be
    // invoked.
    //
    //output.removeAllOutputs();

    monitor.setTotCicles(1);

    monitor.removeAllListeners();
    monitor.addNeuralNetListener(getSpectrumScholarPanel().getSpectrumRecognitionPanel().getNeuralNetListener());

    // inputArray.length suppose to be 1.
    monitor.setTrainingPatterns(inputArray.length);
    monitor.setLearning(false);

    MemoryInputSynapse memInp = new MemoryInputSynapse();
    memInp.setAdvancedColumnSelector("1-" + numOfInput);
    memInp.setInputArray(inputArray);
    memInp.setFirstRow(1);
    memInp.setLastRow(0);

    input.addInputSynapse(memInp);

    MemoryOutputSynapse memOut = new MemoryOutputSynapse();
    output.addOutputSynapse(memOut);

    input.start();
    hidden.start();
    output.start();

    monitor.Go();
    //monitor.runAgain();

    // We only interested in the first pattern.
    double[] tmp = memOut.getNextPattern();

    monitor.Stop();

    output.stop();
    hidden.stop();
    input.stop();

    return tmp;
  }

  public void trainNetwork(int numOfInput, int numOfHidden, int numOfOutput, int totalCircle, double learningRate,
                           double momentum, double[][] inputArray) {
    // Clear the previous graph.
    neuralNetworkGraphPanel.getNeuralNetworkGraph().clear();

    input = new SigmoidLayer();
    hidden = new SigmoidLayer();
    output = new SigmoidLayer();
    input.setLayerName("input");
    hidden.setLayerName("hidden");
    output.setLayerName("output");

    // sets their dimensions
    input.setRows(numOfInput);
    hidden.setRows(numOfHidden);
    output.setRows(numOfOutput);

    // Now create the two Synapses
    // input -> hidden conn.
    FullSynapse synapse_IH = new FullSynapse();
    // hidden -> output conn.
    FullSynapse synapse_HO = new FullSynapse();

    synapse_IH.setName("IH");
    synapse_HO.setName("HO");
    t1 = synapse_IH;
    t2 = synapse_HO;

    // Connect the input layer with the hidden layer
    input.addOutputSynapse(synapse_IH);
    hidden.addInputSynapse(synapse_IH);

    // Connect the hidden layer with the output layer
    hidden.addOutputSynapse(synapse_HO);
    output.addInputSynapse(synapse_HO);

    // Create the Monitor object and set the learning parameters
    monitor = new Monitor();
    monitor.setLearningRate(learningRate);
    monitor.setMomentum(momentum);
    monitor.addNeuralNetListener(neuralNetworkControlPanel);

    // Now we interrogate the net
    monitor.setTotCicles(totalCircle);
    monitor.setTrainingPatterns(inputArray.length);
    monitor.setLearning(true);

    // Pass the Monitor to all components
    input.setMonitor(monitor);
    hidden.setMonitor(monitor);
    output.setMonitor(monitor);

    // The application registers itself as monitor's listener
    // so it can receive the notifications of termination from
    // the net.


    MemoryInputSynapse memInp = new MemoryInputSynapse();
    memInp.setAdvancedColumnSelector("1-" + numOfInput);
    memInp.setInputArray(inputArray);
    memInp.setFirstRow(1);
    memInp.setLastRow(0);

    input.addInputSynapse(memInp);

    // Setting of the file containing the desired responses,
    // provided by a FileInputSynapse
    MemoryInputSynapse memInpTeach = new MemoryInputSynapse();
    if (1 < numOfOutput) {
      memInpTeach.setAdvancedColumnSelector((numOfInput + 1) + "-" + (numOfInput + numOfOutput));
    } else {
      memInpTeach.setAdvancedColumnSelector("" + (numOfInput + 1));
    }
    memInpTeach.setInputArray(inputArray);
    memInpTeach.setFirstRow(1);
    memInpTeach.setLastRow(0);

    trainer = new TeachingSynapse();
    trainer.setMonitor(monitor);
    trainer.setDesired(memInpTeach);

    // Connects the Teacher to the last layer of the net
    output.addOutputSynapse(trainer);

    input.start();
    hidden.start();
    output.start();

    monitor.Go();
  }

  public void updateInfo() {
    neuralNetworkControlPanel.updateInfo();
  }

  public boolean restoreNeuralNetwork(String fileName) {
    try {
      FileInputStream stream = new FileInputStream(fileName);
      ObjectInputStream inp = new ObjectInputStream(stream);
      input = (SigmoidLayer) inp.readObject();
      hidden = (SigmoidLayer) inp.readObject();
      output = (SigmoidLayer) inp.readObject();
      monitor = input.getMonitor();
    }
    catch (Exception excp) {
      excp.printStackTrace();
      return false;
    }

    return true;
  }

  public boolean saveNeuralNetwork(String fileName) {
    if (input == null || hidden == null || output == null) {
      return false;
    }

    try {
      FileOutputStream stream = new FileOutputStream(fileName);
      ObjectOutputStream out = new ObjectOutputStream(stream);
      out.writeObject(input);
      out.writeObject(hidden);
      out.writeObject(output);
    }
    catch (Exception excp) {
      excp.printStackTrace();
      return false;
    }

    return true;
  }

  public void clear() {
    neuralNetworkGraphPanel.clear();
  }

  public int getInputRows() {
    if (input == null) {
      return 0;
    }

    return input.getRows();
  }

  public int getHiddenRows() {
    if (hidden == null) {
      return 0;
    }

    return hidden.getRows();
  }

  public int getOutputRows() {
    if (output == null) {
      return 0;
    }

    return output.getRows();
  }

  public double getMomentum() {
    if (input == null) {
      return 0;
    }

    if (input.getMonitor() == null) {
      return 0;
    }

    return input.getMonitor().getMomentum();
  }

  public double getLearningRate() {
    if (input == null) {
      return 0;
    }

    if (input.getMonitor() == null) {
      return 0;
    }

    return input.getMonitor().getLearningRate();
  }

  public void addError(double error) {
    neuralNetworkGraphPanel.getNeuralNetworkGraph().addError(error);
  }

  ProjectEnvironment getProjectEnvironment() {
    return getSpectrumScholarPanel().getProjectEnvironment();
  }

  SpectrumScholarPanel getSpectrumScholarPanel() {
    Container aparent = getParent();
    while (aparent != null && !(aparent instanceof SpectrumScholarPanel)) {
      aparent = aparent.getParent();
    }
    if (aparent != null)
      return (SpectrumScholarPanel) aparent;
    else
      return null;
  }

}
